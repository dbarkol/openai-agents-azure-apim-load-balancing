<policies>
    <inbound>
        <base />
        <!-- 
            Track session for monitoring 
        
            * Parse the incoming cookie header for SessionBackend=<value>
            * Extract the session ID if it exists and store in sessionCookie variable
            * Return empty string if no session cookie is found
        -->
        <set-variable name="sessionCookie" value="@{
            string cookieHeader = context.Request.Headers.GetValueOrDefault("Cookie", "");
            if (cookieHeader.Contains("SessionBackend="))
            {
                string[] cookies = cookieHeader.Split(';');
                foreach (string cookie in cookies)
                {
                    string trimmed = cookie.Trim();
                    if (trimmed.StartsWith("SessionBackend="))
                    {
                        return trimmed.Substring(15);
                    }
                }
            }
            return "";
        }" />

        <!-- 
            Always use the pool (it has built-in load balancing) 

            * Pool likely contains multiple Azure OpenAI instances across regions
            * Built-in load balancing distributes requests across pool members
        -->
        <set-backend-service backend-id="openai-backend-pool" />

        <!--          
            Authentication 
            
            * Remove incoming api-key header
            * Use Azure Managed Identity to authenticate with Cognitive Services
            * Rewrite URI to the OpenAI chat completions endpoint
        -->
        <set-header name="api-key" exists-action="delete" />
        <authentication-managed-identity resource="https://cognitiveservices.azure.com" />
        <rewrite-uri template="/v1/chat/completions" />

    </inbound>
    <backend>
        <base />
    </backend>
    <outbound>
        <base />

        <!-- 
            Set session cookie for new sessions 
        
            * If not session cookie found, create a new one
            * Generate a session ID using the timestamp + requestID for uniqueness
            * Set Set-Cookie header with security flags:
                - HttpOnly: prevents JavaScript access
                - SameSite=Strict: CSRF protection
                - Max-Age=3600: 1 hour expiration
                - Path=/: applies to all paths
        -->
        <choose>
            <when condition="@(string.IsNullOrEmpty((string)context.Variables["sessionCookie"]))">
                <!-- Use a generic session ID based on request/response -->
                <set-variable name="sessionId" value="@{
                    // Generate session ID from request timestamp and backend info
                    string timestamp = DateTime.UtcNow.Ticks.ToString();
                    string requestId = context.RequestId.ToString();
                    return "session-" + timestamp.Substring(timestamp.Length - 8) + "-" + requestId.Substring(0, 8);
                }" />
                <set-header name="Set-Cookie" exists-action="override">
                    <value>@("SessionBackend=" + (string)context.Variables["sessionId"] + "; Path=/; HttpOnly; SameSite=Strict; Max-Age=3600")</value>
                </set-header>
            </when>
        </choose>
        
        <!--         
            Debug headers for troubleshooting

            * Current session identifier
            * Which pool handled the request
            * APIM internal request ID
        -->
        <set-header name="X-Session-Id" exists-action="override">
            <value>@((string)context.Variables.GetValueOrDefault("sessionId", (string)context.Variables["sessionCookie"]))</value>
        </set-header>
        <set-header name="X-Backend-Pool" exists-action="override">
            <value>openai-backend-pool</value>
        </set-header>
        <set-header name="X-Request-Id" exists-action="override">
            <value>@(context.RequestId.ToString())</value>
        </set-header>
    </outbound>
    <on-error>
        <base />
    </on-error>
</policies>